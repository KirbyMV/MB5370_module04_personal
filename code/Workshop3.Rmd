---
title: "Workshop3"
output: html_document
date: "2025-09-17"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
```
# Lengthening datasets

pivot data to make it tidy. pivot_longer() usually solves a lot of data problems by increasing the number of rows and decreasing the number of columns.

```{r}
billboard |> 
  pivot_longer(
    cols = starts_with("wk"), 
    names_to = "week", 
    values_to = "rank"
  )
```
cols specifies the columns you want to pivot
names_to names the variable stored in column names
values_to names the variable stored in the cell values
values_drop_na = TRUE can remove NAs that were created when pivoting simply because the data did not exist

```{r}
billboard |> 
  pivot_longer(
    cols = starts_with("wk"), 
    names_to = "week", 
    values_to = "rank",
    values_drop_na = TRUE
  )
```

# Pivoting longer

Create tribble
```{r}
df <- tribble(
  ~id,  ~bp1, ~bp2,
   "A",  100,  120,
   "B",  140,  115,
   "C",  120,  125
)
```

we want it to have three variables: id, measurement, value

```{r}
df |> 
  pivot_longer(
    cols = bp1:bp2,
    names_to = "measurement",
    values_to = "value"
  )
```

# Widening datasets

Helps when the observation is scattered across multiple rows.
```{r}
cms_patient_experience
```

Each organization is spread across six rows 

```{r}
cms_patient_experience |> 
  distinct(measure_cd, measure_title)
```

values_from: provide existing columns that define the values
names_from: column name

```{r}
cms_patient_experience |> 
  pivot_wider(
      names_from = measure_cd,
    values_from = prf_rate
  )
```
Need to tell it which columns have values that uniquely identify each row
```{r}
cms_patient_experience |> 
  pivot_wider(
    id_cols = starts_with("org"),
    names_from = measure_cd,
    values_from = prf_rate
  )
```

# Pivoting wider 

```{r}
df <- tribble(
  ~id, ~measurement, ~value,
  "A",        "bp1",    100,
  "B",        "bp1",    140,
  "B",        "bp2",    115, 
  "A",        "bp2",    120,
  "A",        "bp3",    105
)
```

```{r}
df |> 
  pivot_wider(
    names_from = measurement,
    values_from = value
  )
```
new column names: unique values of measurement
```{r}
df |> 
  distinct(measurement) |> 
  pull()
```

```{r}
df |> 
  select(-measurement, -value) |> 
  distinct()
```

pivot_wider combines these results to generate an empty dataframe
```{r}
df |> 
  select(-measurement, -value) |> 
  distinct() |> 
  mutate(x = NA, y = NA, z = NA)
```
Then it fills in all the missing values using the dta in the input.

# Exercises

Why are pivot_longer and pivot_wider not perfectly symmetrical? Consider the example:
```{r}
stocks <- tibble(
  year   = c(2015, 2015, 2016, 2016),
  half  = c(   1,    2,     1,    2),
  return = c(1.88, 0.59, 0.92, 0.17)
)
stocks %>% 
  pivot_wider(names_from = year, values_from = return) %>% 
  pivot_longer(`2015`:`2016`, names_to = "year", values_to = "return")
```
Pivoting reorders the data, so pivoting wider and then longer will reorder them.

Why does this code fail?
```{r}
table4a %>% 
  pivot_longer(c(1999, 2000), names_to = "year", values_to = "cases")
```
```{r}
table4a %>% 
  pivot_longer(cols = c("1999", "2000"), names_to = "year", values_to = "cases")
```
1999 and 2000 aren't in quotes.

Consider the sample tibble below. Do you need to make it wider or longer? What are the variables?
```{r}
preg <- tribble(
  ~pregnant, ~male, ~female,
  "yes",     NA,    10,
  "no",      20,    12
)
```
variables: sex, pregnant
4 observations
need to make it longer.

# Separating and uniting data tables

```{r}
table3
```
Need to separate rate into cases and population

```{r}
table3 %>% 
  separate(rate, into = c("cases", "population"))
```
separate by default splits values whenever it sees a non alphanumeric character.

Could also rewrite like this:
```{r}
table3 %>% 
  separate(rate, into = c("cases", "population"), sep = "/")
```

We ask separate to convert into better types using convert = TRUE

```{r}
table3 %>% 
  separate(rate, into = c("cases", "population"), convert = TRUE)
```
you can also use a vector of integers to separate. can use this to separate the last two digits of each year.
```{r}
table3 %>% 
  separate(year, into = c("century", "year"), sep = 2)
```

Using unite: combine multiple columns into one

```{r}
table5 %>% 
  unite(new, century, year, sep = "")
```

# Explicit missing values

NA means absent data. Blank means implicitly absent data.
```{r}
treatment <- tribble(
  ~person,           ~treatment, ~response,
  "Derrick Whitmore", 1,         7,
  NA,                 2,         10,
  NA,                 3,         NA,
  "Katherine Burke",  1,         4
)
```

Can fill in missing values using fill

```{r}
treatment |>
  fill(everything())
```
# Fixed values

Sometimes missing values represent zero. Use coalesce to replace them.

```{r}
x <- c(1, 4, 5, 7, NA)
coalesce(x, 0)
```
Sometimes values like -99 represent missing values
```{r}
x <- c(1, 4, 5, 7, -99)
na_if(x, -99)
```

# NaN

NaN means Not a Number. Usually behaves the same as NA

```{r}
x <- c(NA, NaN)
x * 10
x == 1
is.na(x)
```

# Implicit missing values

```{r}
stocks <- tibble(
  year  = c(2020, 2020, 2020, 2020, 2021, 2021, 2021),
  qtr   = c(   1,    2,    3,    4,    2,    3,    4),
  price = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)
)
```

The price in the fourth quarter of 2020 is explicitly missing, because its value is NA.
The price for the first quarter of 2021 is implicitly missing, because it simply does not appear in the dataset.

Here’s another example where if we pivot stocks wider to put the quarter in the columns, both missing values become explicit:
```{r}
stocks |>
  pivot_wider(
        names_from = qtr, 
    values_from = price
  )
```

# CSV files

comma separated values. looks like this:
```{r}
Student ID,Full Name,favourite.food,mealPlan,AGE 1,Sunil Huffmann,Strawberry yoghurt,Lunch only,4 2,Barclay Lynn,French fries,Lunch only,5 3,Jayendra Lyne,N/A,Breakfast and lunch,7 4,Leon Rossini,Anchovies,Lunch only, 5,Chidiegwu Dunkel,Pizza,Breakfast and lunch,five 6,Güvenç Attila,Ice cream,Lunch only,6
```
The first row or “header row” gives the column names
The following six rows provide the data. 

Use read_csv to read it from a file into R.
example:
```{r}
? read_csv
students <- read_csv("C://data/students.csv")
```

now read it from the url
```{r}
students <- read_csv("https://pos.it/r4ds-students-csv")
```

# Practical advice

Are observations in rows?  
Are variables in columns?

Check whether data is valid

```{r}
students
```

Need to recognize N/A as NA

```{r}
students <- read_csv("https://pos.it/r4ds-students-csv", na = c("N/A", ""))

students
```
rename columns to remove spaces because otherwise you'll need to use backticks everytime

```{r}
students |> 
  rename(
    student_id = `Student ID`,
    full_name = `Full Name`
  )
```

# Exercises 

Identify what is wrong with each of the following inline CSV files. What happens when you run the code?

```{r}
read_csv("a,b\n1,2,3\n4,5,6")
```

It splits the numbers unevenly because there's only 2 columns
```{r}
read_csv("a,b,c\n1,2\n1,2,3,4")
```
There are only 3 columns so it squishes the last two numbers into the last column.

```{r}
read_csv("a,b\n\"1")
```
The quotes are wrong.
```{r}
read_csv("a,b\n1,2\na,b")
```
this one looks good if the intention is to have the column names as observations

```{r}
read_csv("a;b\n1;3")
```
It uses semicolons to separate values instead of commas.
